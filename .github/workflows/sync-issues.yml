# Sincroniza archivos .md en .github/issues/ con GitHub Issues
# - Crea issues cuando se agregan archivos .md
# - Elimina archivos cuando los issues se cierran

name: Sync Issues from Files

env:
  PROTOCOL_VERSION: "1.3.0"

on:
  # Cuando se modifican archivos en la carpeta de issues
  push:
    paths:
      - ".github/issues/*.md"
    branches:
      - main

  # Cuando se cierra un issue
  issues:
    types: [closed, deleted]

  # Manual trigger
  workflow_dispatch:
    inputs:
      action:
        description: "Action to perform"
        required: true
        default: "sync"
        type: choice
        options:
          - sync
          - push-only
          - pull-only

  # Peri√≥dicamente para limpiar issues cerrados
  # Using minute 23 to avoid hourly peak congestion
  schedule:
    - cron: "23 */6 * * *" # Every 6 hours at minute 23

permissions:
  contents: write
  issues: write

jobs:
  sync-issues:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup jq
        run: sudo apt-get install -y jq

      - name: Initialize mapping file
        run: |
          mkdir -p .github/issues
          if [[ ! -f .github/issues/.issue-mapping.json ]]; then
            echo "{}" > .github/issues/.issue-mapping.json
          fi

      # ========== Ensure labels exist ==========
      - name: Create missing labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Define labels that might be needed
          declare -A LABELS=(
            ["ai-agents"]="AI agent related tasks:#5319E7"
            ["research"]="Research tasks:#D4C5F9"
            ["workflow"]="Workflow improvements:#0E8A16"
            ["bug"]="Something isn't working:#D73A4A"
            ["documentation"]="Improvements or additions to documentation:#0075CA"
            ["feature"]="New feature request:#A2EEEF"
            ["enhancement"]="New feature or improvement:#A2EEEF"
            ["protocol"]="Git-Core Protocol related:#1D76DB"
            ["dependencies"]="Dependency updates:#0366D6"
            ["copilot"]="Assigned to GitHub Copilot:#6F42C1"
          )

          for label in "${!LABELS[@]}"; do
            IFS=':' read -r desc color <<< "${LABELS[$label]}"
            gh label create "$label" --description "$desc" --color "$color" 2>/dev/null || true
          done
          echo "‚úÖ Labels verificados"

      # ========== PUSH: Crear issues desde archivos .md ==========
      - name: Create issues from .md files
        if: github.event_name != 'issues' && (github.event.inputs.action != 'pull-only' || github.event.inputs.action == '')
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Sincronizando archivos .md ‚Üí GitHub Issues..."

          MAPPING_FILE=".github/issues/.issue-mapping.json"

          for file in .github/issues/*.md; do
            [[ -f "$file" ]] || continue

            filename=$(basename "$file")

            # Saltar templates y archivos especiales
            [[ "$filename" == _* ]] && continue
            [[ "$filename" == ".gitkeep" ]] && continue

            # Verificar si ya existe en el mapeo
            existing=$(jq -r ".[\"$filename\"] // empty" "$MAPPING_FILE")
            if [[ -n "$existing" ]]; then
              echo "  ‚è≠Ô∏è  $filename ya mapeado a #$existing"
              continue
            fi

            # Parsear frontmatter
            content=$(cat "$file")

            # Extraer t√≠tulo
            TITLE=$(echo "$content" | sed -n '/^---$/,/^---$/p' | grep -E '^title:' | sed 's/title:[[:space:]]*"\?\([^"]*\)"\?/\1/' | head -1)

            # Si no hay t√≠tulo, usar nombre del archivo
            if [[ -z "$TITLE" ]]; then
              TITLE=$(echo "$filename" | sed 's/.md$//' | tr '_' ':' | tr '-' ' ')
            fi

            # Extraer labels
            LABELS=$(echo "$content" | sed -n '/^---$/,/^---$/p' | sed -n '/^labels:/,/^[a-z]/p' | grep -E '^\s*-' | sed 's/.*-[[:space:]]*"\?\([^"]*\)"\?/\1/' | tr '\n' ',' | sed 's/,$//')

            # Extraer body (todo despu√©s del segundo ---)
            BODY=$(echo "$content" | sed '1,/^---$/d' | sed '1,/^---$/d')

            echo "üìù Creando issue: $TITLE"

            # Construir comando
            CMD="gh issue create --title \"$TITLE\""

            # Agregar labels
            if [[ -n "$LABELS" ]]; then
              IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
              for label in "${LABEL_ARRAY[@]}"; do
                label=$(echo "$label" | xargs)
                if [[ -n "$label" ]]; then
                  CMD="$CMD --label \"$label\""
                fi
              done
            fi

            # Crear archivo temporal para body
            echo "$BODY" > /tmp/issue_body.md
            CMD="$CMD --body-file /tmp/issue_body.md"

            # Ejecutar con manejo de errores robusto
            set +e
            result=$(eval $CMD 2>&1)
            exit_code=$?
            set -e

            # Extraer n√∫mero del issue
            issue_num=$(echo "$result" | grep -oE '/issues/[0-9]+' | grep -oE '[0-9]+')

            if [[ -n "$issue_num" ]]; then
              echo "‚úÖ Issue #$issue_num creado"

              # Actualizar mapping
              tmp=$(mktemp)
              jq ".[\"$filename\"] = $issue_num" "$MAPPING_FILE" > "$tmp" && mv "$tmp" "$MAPPING_FILE"

              # Agregar n√∫mero al archivo
              if ! grep -q "github_issue:" "$file"; then
                sed -i "s/^---$/---\ngithub_issue: $issue_num/" "$file"
              fi
            else
              echo "‚ùå Error creando issue: $result"
            fi
          done

      # ========== PULL: Eliminar archivos de issues cerrados ==========
      - name: Clean closed issues
        if: github.event.inputs.action != 'push-only' || github.event.inputs.action == ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Limpiando archivos de issues cerrados..."

          MAPPING_FILE=".github/issues/.issue-mapping.json"

          # Si el trigger es un issue cerrado espec√≠fico
          if [[ "${{ github.event_name }}" == "issues" && "${{ github.event.action }}" == "closed" ]]; then
            closed_num="${{ github.event.issue.number }}"
            echo "Issue #$closed_num fue cerrado"

            # Buscar archivo correspondiente
            filename=$(jq -r "to_entries[] | select(.value == $closed_num) | .key" "$MAPPING_FILE")

            if [[ -n "$filename" ]]; then
              filepath=".github/issues/$filename"
              if [[ -f "$filepath" ]]; then
                rm -f "$filepath"
                echo "‚úÖ Eliminado: $filename"
              fi

              # Actualizar mapping
              tmp=$(mktemp)
              jq "del(.[\"$filename\"])" "$MAPPING_FILE" > "$tmp" && mv "$tmp" "$MAPPING_FILE"
            fi
          else
            # Verificar todos los issues en el mapping
            keys=$(jq -r 'keys[]' "$MAPPING_FILE" 2>/dev/null || true)

            for filename in $keys; do
              issue_num=$(jq -r ".[\"$filename\"]" "$MAPPING_FILE")

              # Verificar estado del issue
              state=$(gh issue view "$issue_num" --json state --jq '.state' 2>/dev/null || echo "CLOSED")

              if [[ "$state" == "CLOSED" ]]; then
                filepath=".github/issues/$filename"

                if [[ -f "$filepath" ]]; then
                  rm -f "$filepath"
                  echo "‚úÖ Eliminado: $filename (issue #$issue_num cerrado)"
                fi

                # Actualizar mapping
                tmp=$(mktemp)
                jq "del(.[\"$filename\"])" "$MAPPING_FILE" > "$tmp" && mv "$tmp" "$MAPPING_FILE"
              fi
            done
          fi

      # ========== Commit cambios ==========
      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .github/issues/

          if git diff --staged --quiet; then
            echo "No hay cambios que commitear"
          else
            git commit -m "chore(issues): sync issue files with GitHub Issues [skip ci]"
            git push
          fi
